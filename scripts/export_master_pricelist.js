const path = require('path');
const env = process.env.NODE_ENV || 'production';
const envPath = path.resolve(__dirname, `../.env.${env}`);
require('dotenv').config({ path: envPath });
console.log(`✅ Loaded environment: ${env} from ${envPath}`);

const fs = require('fs');
const crypto = require('crypto');
const axios = require('axios');
const ExcelJS = require('exceljs');
const utilities = require('../src/utils/utilities.pricing');
const Product = require('../src/models/Product');

const projectRoot = path.resolve(__dirname, '..');

function base64UrlEncode(input) {
	const buffer = Buffer.isBuffer(input) ? input : Buffer.from(input);
	return buffer
		.toString('base64')
		.replace(/=/g, '')
		.replace(/\+/g, '-')
		.replace(/\//g, '_');
}

function columnIndexToLetter(index) {
	let column = '';
	let remainder = index;
	while (remainder > 0) {
		const letterIndex = (remainder - 1) % 26;
		column = String.fromCharCode(65 + letterIndex) + column;
		remainder = Math.floor((remainder - 1) / 26);
	}
	return column;
}

function resolveFromProjectRoot(filePath) {
	if (!filePath) return filePath;
	return path.isAbsolute(filePath)
		? filePath
		: path.resolve(projectRoot, filePath);
}

function logAxiosError(context, error) {
	if (error?.response) {
		const { status, statusText, data } = error.response;
		console.error(`❌ ${context} failed (${status} ${statusText})`);
		if (data) {
			console.error('Details:', JSON.stringify(data, null, 2));
		}
		return;
	}

	if (error?.request) {
		console.error(`❌ ${context} failed (no response received).`);
		return;
	}

	console.error(`❌ ${context} failed: ${error?.message || error}`);
}

function buildIntroductionSheet(workbook, metadata) {
	const sheet = workbook.addWorksheet('Introduction');
	sheet.columns = [{ width: 26 }, { width: 95 }];
	sheet.views = [{ state: 'frozen', ySplit: 4 }];

	sheet.mergeCells('A1:B1');
	const titleCell = sheet.getCell('A1');
	titleCell.value = 'Master Pricelist - Deck Family Farm';
	titleCell.font = { size: 16, bold: true };
	titleCell.alignment = { vertical: 'middle' };
	titleCell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFEFEFEF' } };
	sheet.getRow(1).height = 24;

	sheet.mergeCells('A2:B2');
	const subtitleCell = sheet.getCell('A2');
	subtitleCell.value = 'Generated from database extract and synced automatically.';
	subtitleCell.font = { size: 11, italic: true, color: { argb: 'FF555555' } };
	subtitleCell.alignment = { wrapText: true };

	const rows = [
		[],
		['Metadata'],
		['Sync time (UTC)', metadata.syncTimeUtc],
		['Environment', metadata.environment],
		['Generated by', 'scripts/export_master_pricelist.js'],
		['Source', 'MySQL table: pricelist'],
		['Sort order', 'category_id, productName'],
		['Output file', metadata.outputFile],
		['Sheets included', 'Introduction, Pricelist, Variables'],
		['Variables source', 'src/utils/utilities.pricing.js'],
		['Google sheet', metadata.spreadsheetSummary],
		[],
		['Assumptions'],
		['Boolean columns', 'tinyint(1) rendered as True/False'],
		['Empty values', 'NULL values rendered as empty strings'],
		['Formats', 'Currency and percent formats applied in Excel only'],
		['Sync behavior', 'Google sync replaces all data in the prices tab'],
	];

	let rowIndex = 3;
	for (const row of rows) {
		rowIndex += 1;
		sheet.addRow(row);

		if (row.length === 1 && row[0]) {
			sheet.mergeCells(`A${rowIndex}:B${rowIndex}`);
			const headerCell = sheet.getCell(`A${rowIndex}`);
			headerCell.font = { bold: true };
			headerCell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFDCE6F1' } };
		}

		if (row.length === 2) {
			sheet.getCell(`A${rowIndex}`).font = { bold: true };
			sheet.getCell(`B${rowIndex}`).alignment = { wrapText: true };
		}
	}

	const introValues = [
		['Master Pricelist - Deck Family Farm'],
		['Generated from database extract and synced automatically.'],
		[],
		['Metadata'],
		['Sync time (UTC)', metadata.syncTimeUtc],
		['Environment', metadata.environment],
		['Generated by', 'scripts/export_master_pricelist.js'],
		['Source', 'MySQL table: pricelist'],
		['Sort order', 'category_id, productName'],
		['Output file', metadata.outputFile],
		['Sheets included', 'Introduction, Pricelist, Variables'],
		['Variables source', 'src/utils/utilities.pricing.js'],
		['Google sheet', metadata.spreadsheetSummary],
		[],
		['Assumptions'],
		['Boolean columns', 'tinyint(1) rendered as True/False'],
		['Empty values', 'NULL values rendered as empty strings'],
		['Formats', 'Currency and percent formats applied in Excel only'],
		['Sync behavior', 'Google sync replaces all data in the prices tab'],
	];

	return introValues;
}

async function getServiceAccountAccessToken(credentialsPath) {
	const resolvedPath = resolveFromProjectRoot(credentialsPath);
	const credentials = JSON.parse(fs.readFileSync(resolvedPath, 'utf8'));
	const issuedAt = Math.floor(Date.now() / 1000);
	const expiresAt = issuedAt + 60 * 60;

	const header = { alg: 'RS256', typ: 'JWT' };
	const claimSet = {
		iss: credentials.client_email,
		scope: 'https://www.googleapis.com/auth/spreadsheets',
		aud: credentials.token_uri || 'https://oauth2.googleapis.com/token',
		iat: issuedAt,
		exp: expiresAt,
	};

	const unsignedToken = `${base64UrlEncode(JSON.stringify(header))}.${base64UrlEncode(JSON.stringify(claimSet))}`;
	const signature = crypto
		.createSign('RSA-SHA256')
		.update(unsignedToken)
		.sign(credentials.private_key);
	const signedJwt = `${unsignedToken}.${base64UrlEncode(signature)}`;

	const params = new URLSearchParams({
		grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',
		assertion: signedJwt,
	});

	const response = await axios.post(credentials.token_uri, params.toString(), {
		headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
	});

	return response.data.access_token;
}

async function updateGoogleSheet({ accessToken, spreadsheetId, sheetName, values }) {
	const encodedSheet = encodeURIComponent(sheetName);
	const columnCount = values.reduce((max, row) => Math.max(max, row?.length || 0), 1);
	const rowCount = values.length || 1;
	const endColumn = columnIndexToLetter(columnCount);
	const range = `${sheetName}!A1:${endColumn}${rowCount}`;

	const client = axios.create({
		baseURL: 'https://sheets.googleapis.com/v4/spreadsheets',
		headers: { Authorization: `Bearer ${accessToken}` },
	});

	try {
		await client.post(`/${spreadsheetId}/values/${encodedSheet}:clear`, {});
	} catch (error) {
		logAxiosError('Google Sheets clear', error);
		throw error;
	}

	try {
		await client.put(
			`/${spreadsheetId}/values/${encodeURIComponent(range)}?valueInputOption=RAW`,
			{
				range,
				majorDimension: 'ROWS',
				values,
			}
		);
	} catch (error) {
		logAxiosError('Google Sheets update', error);
		throw error;
	}
}

async function syncPricelistToGoogleSheet(sheetValues, introductionValues) {
	const credentialsPath = process.env.GOOGLE_APPLICATION_CREDENTIALS;
	const spreadsheetId = process.env.GOOGLE_SHEETS_SPREADSHEET_ID;
	const sheetName = process.env.GOOGLE_SHEETS_TAB_NAME;
	const hasAnyConfig = credentialsPath || spreadsheetId || sheetName;

	if (!hasAnyConfig) {
		console.log('ℹ️ Google Sheets sync skipped (missing env vars).');
		return;
	}

	if (!credentialsPath || !spreadsheetId || !sheetName) {
		throw new Error('Missing GOOGLE_APPLICATION_CREDENTIALS, GOOGLE_SHEETS_SPREADSHEET_ID, or GOOGLE_SHEETS_TAB_NAME.');
	}

	const accessToken = await getServiceAccountAccessToken(credentialsPath);
	await updateGoogleSheet({
		accessToken,
		spreadsheetId,
		sheetName,
		values: sheetValues,
	});
	console.log(`✅ Google Sheet updated: ${spreadsheetId} (${sheetName})`);

	if (introductionValues?.length) {
		const introSheetName = process.env.GOOGLE_SHEETS_INTRO_TAB_NAME || 'Introduction';
		try {
			await updateGoogleSheet({
				accessToken,
				spreadsheetId,
				sheetName: introSheetName,
				values: introductionValues,
			});
			console.log(`✅ Google Sheet updated: ${spreadsheetId} (${introSheetName})`);
		} catch (error) {
			logAxiosError('Google Sheets introduction update', error);
		}
	}
}

async function exportPricelistToExcel() {
	try {
		const syncTimestamp = new Date();
		const [columns] = await utilities.db.execute("SHOW COLUMNS FROM pricelist");
		const booleanColumns = columns
			.filter(col => col.Type.includes("tinyint(1)"))
			.map(col => col.Field);

		const orderedColumnNames = [
			"id", "localLineProductID", "category", "productName", "packageName",
			"retailSalesPrice", "lowest_weight", "highest_weight", "dff_unit_of_measure",
			"wholesalePricePerLb", "retailPackagePrice", "ffcsaPurchasePrice", "ffcsaMemberSalesPrice", "ffcsaGuestSalesPrice", "guestPercentOverRetail",
			"num_of_items", "available_on_ll", "description",
			"track_inventory", "stock_inventory", "visible"
		];

		const formatColumns = {
			"retailSalesPrice": "$#,##0.00",
			"lowest_weight": "0.00",
			"highest_weight": "0.00",
			"retailPackagePrice": "$#,##0.00",
			"wholesalePricePerLb": "$#,##0.00",
			"ffcsaPurchasePrice": "$#,##0.00",
			"ffcsaMemberSalesPrice": "$#,##0.00",
			"ffcsaGuestSalesPrice": "$#,##0.00",
			"guestPercentOverRetail": "0.0%"
		};

		const workbook = new ExcelJS.Workbook();
		const spreadsheetId = process.env.GOOGLE_SHEETS_SPREADSHEET_ID;
		const tabName = process.env.GOOGLE_SHEETS_TAB_NAME || 'prices';
		const spreadsheetSummary = spreadsheetId
			? `${spreadsheetId} (tab: ${tabName})`
			: 'Not configured';
		const introValues = buildIntroductionSheet(workbook, {
			syncTimeUtc: syncTimestamp.toISOString(),
			environment: env,
			outputFile: '../docs/masterPriceList.xlsx',
			spreadsheetSummary,
		});

		const worksheet = workbook.addWorksheet('Pricelist');
		worksheet.addRow(orderedColumnNames);

		const sheetValues = [orderedColumnNames];
		const [rows] = await utilities.db.execute('SELECT id FROM pricelist ORDER BY category_id, productName');

		for (const row of rows) {
			const product = new Product(row.id);
			await product.init();

			const data = product.data;
			const pricing = product.pricing;

			const rowData = orderedColumnNames.map(column => {
				if (column === 'retailPackagePrice') {return pricing.retailPackagePrice;}
				if (column === 'guestPercentOverRetail') {return pricing.guestPercentOverRetail;}
				if (column === 'wholesalePricePerLb') {return pricing.wholesalePrice;}
				if (column === 'ffcsaPurchasePrice') return pricing.purchasePrice;
				if (column === 'ffcsaMemberSalesPrice') return pricing.memberSalesPrice;
				if (column === 'ffcsaGuestSalesPrice') return pricing.guestSalesPrice;
				if (column === 'retailSalesPrice') return Number(data[column]);
				if (column === 'lowest_weight') return Number(data[column]);
				if (column === 'highest_weight') return Number(data[column]);
				if (booleanColumns.includes(column)) return data[column] === 1 ? "True" : "False";
				return data[column] ?? "";
			});

			worksheet.addRow(rowData);
			sheetValues.push(rowData.map(value => (value === null || value === undefined) ? "" : value));
		}

		orderedColumnNames.forEach((column, index) => {
			if (formatColumns[column]) {
				worksheet.getColumn(index + 1).numFmt = formatColumns[column];
			}
		});

		const variableSheet = workbook.addWorksheet('Variables');
		variableSheet.getCell('A1').value = 'values';
		variableSheet.getCell('B1').value = 'keys';

		const variableMap = {
			DISCOUNT,
			WHOLESALE_DISCOUNT,
			MEMBER_MARKUP,
			GUEST_MARKUP,
			//utilities.DAIRY_MARKUP,
		};

		let rowIndex = 2;
		for (const [key, value] of Object.entries(variableMap)) {
			variableSheet.getCell(`A${rowIndex}`).value = value;
			variableSheet.getCell(`B${rowIndex}`).value = key;
			rowIndex++;
		}

		const outputFile = '../docs/masterPriceList.xlsx';
		await workbook.xlsx.writeFile(outputFile);
		console.log(`✅ Excel file created: ${outputFile}`);
		await syncPricelistToGoogleSheet(sheetValues, introValues);
		await utilities.db.end();
		console.log("✅ Database connection closed.");
		process.exit(0);

	} catch (error) {
		console.error('❌ Error exporting data:', error);
		process.exit(1);
	}
}

exportPricelistToExcel();
